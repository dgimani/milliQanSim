// created 22-04-2019
// author: Ryan Schmitz (UCSB)

//==============================================================================
#include "mqDetectorConstruction.hh"
#include "mqScintSD.hh"
#include "mqPMTSD.hh"
#include "mqBarParameterisation.hh"
#include "mqPMTParameterisation.hh"
#include "mqUserEventInformation.hh"

#include "MilliQMonopoleFieldSetup.hh"
#include <sstream>
#include <math.h>
#include "globals.hh"
// Includes Physical Constants and System of Units
#include "G4PhysicalConstants.hh"
#include "G4SystemOfUnits.hh"
#include "G4UnitsTable.hh"
#include "G4ios.hh"
#include "G4VUserDetectorConstruction.hh"
#include "G4ThreeVector.hh"
#include "G4TwoVector.hh"
#include "G4GenericTrap.hh"
#include "G4RotationMatrix.hh"
#include "G4Trd.hh"
#include "G4Material.hh"
#include "G4NistManager.hh"
#include "G4RunManager.hh"
#include "G4UserLimits.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"
#include "G4EmCalculator.hh"
#include "G4ParticleDefinition.hh"
#include "G4MuonMinus.hh"
#include "G4MuonPlus.hh"

#include "G4MultiUnion.hh"
#include "G4Box.hh"
#include "G4Para.hh"
#include "G4Sphere.hh"
#include "G4Tubs.hh"
#include "G4EllipticalTube.hh"
#include "G4Trap.hh"
#include "G4Polycone.hh"
#include "G4Polyhedra.hh"
#include "G4UnionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4Region.hh"

#include "G4RunManager.hh"
#include "G4LogicalBorderSurface.hh"
#include "G4LogicalSkinSurface.hh"
#include "G4OpticalSurface.hh"
#include "G4MaterialTable.hh"
#include "G4NistManager.hh"
#include "G4PhysicsVector.hh"

#include "G4Sphere.hh"
#include "G4LogicalVolume.hh"
#include "G4LogicalVolume.hh"

#include "G4PVPlacement.hh"
#include "G4VPVParameterisation.hh"
#include "G4PVParameterised.hh"
#include "globals.hh"
#include "G4SolidStore.hh"
#include "G4LogicalVolumeStore.hh"
#include "G4PhysicalVolumeStore.hh"
#include "G4GeometryManager.hh"

#include "G4LogicalVolume.hh"
#include "G4VPhysicalVolume.hh"
#include "G4PVPlacement.hh"
#include "G4AssemblyVolume.hh"


#include "G4OpticalSurface.hh"
#include "G4LogicalBorderSurface.hh"
#include "G4SDManager.hh"
#include "G4UImanager.hh"

const G4int nLayers = 2; //number of layers in detector. Up here since it defines an array

//const G4String mqOpticalFilePath = "/home/users/ryan/milliQanDemoSim/OpticalData/";
//const G4String mqOpticalFilePath = (std::string)std::getenv("PROJECTDIR")+"/OpticalData/";
const G4String mqOpticalFilePath = "../OpticalData/";
//==============================================================================
mqDetectorConstruction::mqDetectorConstruction() :
    verbose(1)//,solidWorld(0), logicWorld(0), physicWorld(0)
{
	SetDefaults();
}

//==============================================================================
mqDetectorConstruction::~mqDetectorConstruction() {

}
//==============================================================================

//==============================================================================

G4VPhysicalVolume* mqDetectorConstruction::Construct() {

	return SetupGeometry();
}

//==============================================================================

G4VPhysicalVolume* mqDetectorConstruction::SetupGeometry() {

	if (verbose >= 0) {
		G4cout << "MilliQan> Construct geometry." << G4endl;
	}
	G4double fWorld_x = 100.0 * m;
	G4double fWorld_y = 100.0 * m;
	G4double fWorld_z = 100.0 * m;

	G4Material* worldMaterial = G4NistManager::Instance()->FindOrBuildMaterial(
	//			"Galactic");
				"G4_AIR");

	const G4int nEntriesAir = 2;
	G4double photonEnergyAir[nEntriesAir]={ 6.3 * eV,1.5 * eV};
	G4double Air_RIND[nEntriesAir];

	for (int i = 0; i < nEntriesAir; i++) {
		Air_RIND[i]= 1.0;
	}// max value at 440 nm

	G4MaterialPropertiesTable* mptAir = new G4MaterialPropertiesTable();
	mptAir->AddProperty("RINDEX",photonEnergyAir, Air_RIND, nEntriesAir);//->SetSpline(true);
	worldMaterial->SetMaterialPropertiesTable(mptAir);

	G4Box* solidWorld = new G4Box("world", fWorld_x / 2, fWorld_y / 2, fWorld_z / 2);
	G4LogicalVolume* logicWorld = new G4LogicalVolume(solidWorld, worldMaterial, "World", 0, 0,
			0);

	G4VisAttributes* visAttWorld = new G4VisAttributes();
	visAttWorld->SetVisibility(false);
	logicWorld->SetVisAttributes(visAttWorld);

	//Must place the World Physical volume unrotated at (0,0,0).
	G4PVPlacement* physicWorld = new G4PVPlacement(0, // no rotation
			G4ThreeVector(), // at (0,0,0)
			logicWorld, // its logical volume
		"World", // its name
			0, // its mother  volume
			false, // no boolean operations
			0); // copy number

///////////////////////////////    End world //////////////////////////////////////////////////
///////////////////////////////   Start Scintillator/Wrapping  ///////////////////////////////////////////
	//==============================================================================
	// size of Scintillator and wrapping
	//==============================================================================
 

	G4double wrapRefl = 0.97;//0.97;
	G4double scintX = 50/2*mm;
	G4double scintY = 50/2*mm;//50/2*mm;
	G4double scintXY = 50/2*mm;//50/2*mm;
	G4double scintZ  = 600/2*mm;//(each of these dimensions represents the half-width; e.g. this is 600mm long)
	G4double subBarSpacing = 1*mm;
	
	G4double CscintX = 50/2*mm;
	G4double CscintY = 50/2*mm;//50/2*mm;
	G4double CscintXY = 50/2*mm;//50/2*mm;
	G4double CscintZ  = 50/2*mm;//(each of these dimensions represents the half-width; e.g. this is 600mm long)

	G4double airGapThickness = 0.1*mm; //1*mm
	G4double wrapThickness = 0.1*mm; //3*mm
	G4double airgapX = scintX+airGapThickness;	
	G4double airgapY = scintY+airGapThickness;	
	G4double airgapXY = scintXY+airGapThickness;	
	G4double airgapZ = scintZ+airGapThickness;
	G4double wrapX=airgapX+wrapThickness;
	G4double wrapY=airgapY+wrapThickness;
	G4double wrapXY=airgapXY+wrapThickness;
	G4double wrapZ=airgapZ+wrapThickness;
	
	G4double CairGapThickness = 0.1*mm; //1*mm
	G4double CwrapThickness = 0.1*mm; //3*mm
	G4double CairgapX = CscintX+CairGapThickness;	
	G4double CairgapY = CscintY+CairGapThickness;	
	G4double CairgapXY = CscintXY+CairGapThickness;	
	G4double CairgapZ = CscintZ+CairGapThickness;
	G4double CwrapX=CairgapX+CwrapThickness;
	G4double CwrapY=CairgapY+CwrapThickness;
	G4double CwrapXY=CairgapXY+CwrapThickness;
	G4double CwrapZ=CairgapZ+CwrapThickness;

        G4double frontLayerMid = -182.0*cm;
        G4double midLayerMid = -60.0*cm;
        G4double backLayerMid = 65.0*cm;
	G4double fourthLayerMid = 190.0*cm; //called so because the original sim had 3 layers

	//measured from the centers; the gap between the bars
	G4double barSpacingXY = scintXY*2*2+1*cm+1*mm;
	//G4double worldRotation = 0*degree;//-43.1*deg;// (demonstrator rotation)
	G4double worldRotation = -90*deg;// (demonstrator rotation)

	//this is here because the entire geometry is shifted 18cm upwards
        G4double centerOffsetX = 18*cm;
	G4double centerOffsetZ = 9/2*barSpacingXY*std::cos(worldRotation)/std::tan(worldRotation);

	//G4double layerSpacing = 1000*mm; 
	//in visualization this gets swapped, so this is actually 3x2 rather than 2x3
        G4int nBarXCount = 4;//2 //number of bars in grid, so this is NxN
        G4int nBarYCount = 4;//3 //number of bars in grid, so this is NxN
	G4int nBarsX = nBarXCount;
	G4int nBarsY = nBarYCount;

	this->SetNBarPerLayer(nBarXCount*nBarYCount);
	this->SetNLayer(nLayers);
 	
	 G4double outerRadius_pmt   = 51* mm /2.; //26 //52
	 G4double outerRadius_cath  = 46* mm /2.; //46
	 G4double height_pmt        = 147* mm; //142.*mm;
	 G4double height_cath       = 0.5 * mm; //2mm
	 G4double pmtYoffset        = 0*mm;
	 G4double muMetalThickness = 0.5*mm;


	 G4double ScintSlabX = 5*cm/2;//2.54*1/2*cm;//scintXY*2+0.5*mm;
	 G4double ScintSlabY = barSpacingXY*(nBarsY)/2+10*cm;
	 G4double ScintSlabZ = barSpacingXY*(nBarsY)/2+10*cm;//0;//2.54*1/2*cm; //inch thickness
	 G4double ScintSlabWrapX = ScintSlabX+airGapThickness+wrapThickness;
	 G4double ScintSlabWrapY = ScintSlabY+airGapThickness+wrapThickness;
	 G4double ScintSlabWrapZ = ScintSlabZ+airGapThickness+wrapThickness;
	 G4double ScintSlabAirGapX = ScintSlabX+airGapThickness;
	 G4double ScintSlabAirGapY = ScintSlabY+airGapThickness;
	 G4double ScintSlabAirGapZ = ScintSlabZ+airGapThickness;

	 G4double ScintSlabOffsetX = centerOffsetX;//7.5*cm;
	 G4double ScintSlabOffsetZ0 = -scintZ-ScintSlabZ-0.73*cm; //scintZ-2*cm //-174*cm
	 G4double ScintSlabOffsetZ1 = -scintZ-ScintSlabZ-1.73*cm; //scintZ-3*cm //-53*cm
	 G4double ScintSlabOffsetZ2 = -scintZ-ScintSlabZ-1.23*cm; //scintZ-2.5*cm //72.5*cm;
	 G4double ScintSlabOffsetZ3 = -scintZ-ScintSlabZ-1.23*cm; //scintZ-2.5*cm //72.5*cm;
	 G4double ScintSlabOffsetZEnd = scintZ+height_pmt+ScintSlabZ+5.23*cm; //scintZ-2.5*cm //181.5
	 
	 G4double ScintPanelX = 5.0/2*cm;//6/2*cm;//1.0/2*cm;
	 G4double ScintPanelY = (nBarsX)*scintXY*2+0.5*mm+30*cm/2;
	 G4double ScintPanelZ = nLayers*scintZ+height_pmt/2*2+30*cm/2;
	 G4double ScintPanelWrapX = ScintPanelX+airGapThickness+wrapThickness;
	 G4double ScintPanelWrapY = ScintPanelY+airGapThickness+wrapThickness;
	 G4double ScintPanelWrapZ = ScintPanelZ+airGapThickness+wrapThickness;
	 G4double ScintPanelAirGapX = ScintPanelX+airGapThickness;
	 G4double ScintPanelAirGapY = ScintPanelY+airGapThickness;
	 G4double ScintPanelAirGapZ = ScintPanelZ+airGapThickness;
	 
	G4double ScintPanelOffsetXTop = centerOffsetX+barSpacingXY*(nBarXCount-1)/2+scintX+1.5*cm+7*cm; //16*cm
	G4double ScintPanelOffsetXBottom = centerOffsetX-barSpacingXY*(nBarXCount-1)/2-scintX-1.5*cm-37*cm; //16*cm
	 G4double ScintPanelOffsetXLeft = centerOffsetX-12*cm;//6.65*cm;
	 G4double ScintPanelOffsetXRight = centerOffsetX-12*cm;//6.65*cm;
	 G4double ScintPanelOffsetYRight = 1.1*barSpacingXY*(nBarYCount-1)/2+scintY+1*cm*nBarYCount+15*cm;
	 G4double ScintPanelOffsetYLeft = -ScintPanelOffsetYRight;

	G4double HodoX = 8.6*cm/2; //width
	G4double HodoY = 45*cm/2; //length //horizontal bars by default
	G4double HodoZ = 4.2*cm/2; //thickness

	G4double HodoWrapX = HodoX+wrapThickness;
	G4double HodoWrapY = HodoY+wrapThickness;
	G4double HodoWrapZ = HodoZ+wrapThickness;

	G4double HodoOffsetVertYRight = 4.8*cm;
	G4double HodoOffsetVertYLeft = -HodoOffsetVertYRight;
	G4double HodoOffsetVertX = -2.5*cm;

	G4double HodoOffsetHorXUpper = 10.4*cm;
	G4double HodoOffsetHorXLower = 0.8*cm;
	G4double HodoOffsetHorY = 0*cm;

	G4double HodoOffsetVertZFront = ScintSlabOffsetZ0+frontLayerMid-8.6*cm;
	G4double HodoOffsetHorZFront = ScintSlabOffsetZ0+frontLayerMid-3.9*cm;
	G4double HodoOffsetHorZBack = ScintSlabOffsetZEnd+backLayerMid+5.6*cm;
	G4double HodoOffsetVertZBack = ScintSlabOffsetZEnd+backLayerMid+11.1*cm;

	G4double barSpacingInter = 5*mm;
	//G4double barSpacingInter = 0.5*mm;
	 G4double LeadX = 2*(scintXY+barSpacingInter);//20/2*cm;
	 G4double LeadY = 2*(scintXY+barSpacingInter);//20/2*cm;
	 G4double LeadZ = 5/2*cm;
	 G4double LeadOffsetX = ScintSlabOffsetX;
	 G4double LeadOffsetZ = ScintSlabOffsetZ1-LeadZ-1.5*cm; //same for both Z1,Z2 for LeadShield
	
	 G4double AlSupportX     = 10*cm/2;
         G4double AlSupportY     = ScintSlabY;
         G4double AlSupportZ     = (backLayerMid-frontLayerMid+height_pmt+scintZ*2+13*cm)/2; //360*cm
	 G4double AlSupportXOffset = ScintSlabOffsetX-ScintSlabX-AlSupportX-10*cm;

	 G4double wallThickness = 2*m; //using 2m before
	 G4double wallCylRadius = 1.5*m;//1.45*m;
	 G4double wallCylRadiusOut = wallCylRadius+wallThickness;
	 G4double wallZ = 15*m/2;

	 G4double floorCutoutDepthX = (10*cm+wallCylRadius)/2;
	 G4double floorCutoutDepthY = (-20*cm+wallCylRadius);
	 G4double floorZ = wallZ;
	 G4double overallDetX = ScintPanelOffsetXTop+ScintSlabX;//30*cm; //adding larger buffer to get volume above and below
	 G4double overallDetY = ScintPanelOffsetYRight+ScintPanelY-30*cm; //adding larger buffer since the volumes are angled, PMT is extending, etc.

	 //todo: modify this bool to be able to adjust from single bar mode to demonstrator mode
	//(together with modifying number of layers and bars, etc.)
	 bool SupportStructure = false;
	 G4double AlThickness = 1*cm;

	 G4double SteelThickness = 1*cm;
	 G4double SteelSideLength = 1*m/2;

	 G4double SteelSupportOffsetX = -0.7*m;
	 G4double SteelSupportOffsetZ = 0.8*m;

	G4double detLength = (wrapZ*2+height_pmt+LeadZ*2+10*cm)*nLayers;
	G4double interactionDist=50.0*m;
	G4double barAngleDelta = std::atan(barSpacingXY/(interactionDist));

	G4NistManager* nistMan = G4NistManager::Instance();

///////////////////////////////////////////////////////////////////////////////
	//==========================================================================
	//Scintillator Materials
	//==========================================================================

	//==========================================================================
	// Elements
	//
	//*******************************************************************************************************************************
	G4Element* elH = nistMan->FindOrBuildElement("H");
	G4Element* elC = nistMan->FindOrBuildElement("C");
	G4Element* elO = nistMan->FindOrBuildElement("O");
	G4Element* elK = nistMan->FindOrBuildElement("K");
	G4Element* elNa = nistMan->FindOrBuildElement("Na");
	G4Element* elSi = nistMan->FindOrBuildElement("Si");
	G4Element* elAl = nistMan->FindOrBuildElement("Al");
        G4Element* elCe = nistMan->FindOrBuildElement("Ce"); // Cerium;
        G4Element* elCs = nistMan->FindOrBuildElement("Cs"); // Cesium;
        G4Element* elSb = nistMan->FindOrBuildElement("Sb"); // Antimony;
        G4Element* elB = nistMan->FindOrBuildElement("B"); // Boron;
        G4Element* elBr = nistMan->FindOrBuildElement("Br"); // Bromine;
		
	//mu metal materials	
	G4Element* elNi = nistMan->FindOrBuildElement("Ni"); //Nickel;
	G4Element* elFe = nistMan->FindOrBuildElement("Fe"); //Iron;
	 
          //---------------------------------------------------
          //Borosilicate glass (Schott BK7) (8" PMT window);
          //---------------------------------------------------
          G4Material* matBorGlass = new G4Material("BorGlass", 2.51 * g / cm3, 6);
          matBorGlass->AddElement(elB, 0.040064);
          matBorGlass->AddElement(elO, 0.539562);
          matBorGlass->AddElement(elNa, 0.028191);
          matBorGlass->AddElement(elAl, 0.011644);
          matBorGlass->AddElement(elSi, 0.377220);
          matBorGlass->AddElement(elK, 0.003321);

          //BiAlkali photocathode (NIM A567, p.222) K2CsSb;
          //For the references for the optical properties see ../ref/ComplexRefractionSpectrum_KCSSb.pdf
          //---------------------------------------------------
          // exact composition of the bialkali is unknown, density is the 'realistic' guess!;
          G4Material* matBiAlkali = new G4Material("matBiAlkali", 1.3 * g / cm3, 3);
          matBiAlkali->AddElement(elK, 2);
          matBiAlkali->AddElement(elCs, 1);
          matBiAlkali->AddElement(elSb, 1);

  	G4Material* matCeBr3 = new G4Material("CeBr3", 5.1 * g / cm3, 2);
	matCeBr3->AddElement(elCe, 1);
        matCeBr3->AddElement(elBr, 3);
        matCeBr3->SetMaterialPropertiesTable(SetOpticalPropertiesOfCeBr3());


	
	//there are other parts, but to first order this is 80% Ni, 15% Fe, 5% other stuff, so I'm just going to lump that into Fe
	G4Material* muMetal = new G4Material("muMetal",8.7*g/cm3, 2);
	muMetal->AddElement(elNi,0.8); //80% mass fraction
	muMetal->AddElement(elFe,0.2); //20% mass fraction

	G4Element* elPlastic = nistMan->FindOrBuildElement("G4_POLYSTYRENE");
	//==========================================================================
	// BC-400 plastic scintillator; according to datasheet, elH = 1.103 *elC, elH + elC = 1
	//For the references for the optical properties see ../ref/EmissionSpectrum_BC-400.pdf

	G4Material* matPlScin = new G4Material("plScintillator", 1.032 * g / cm3, 2);
	//matPlScin->AddElement(elC, .4755);
	//matPlScin->AddElement(elH, .5245);
	matPlScin->AddElement(elC, 10);
	matPlScin->AddElement(elH, 11);
	matPlScin->SetMaterialPropertiesTable(SetOpticalPropertiesOfPS());
	matPlScin->GetIonisation()->SetBirksConstant(0.126*mm/MeV); // according to L. Reichhart et al., Phys. Rev, use (0.149*mm/MeV) for neutrons, but otherwise use 0.126
	
	G4VisAttributes* visAttribplScin = new G4VisAttributes(G4Colour::Cyan());
	visAttribplScin->SetVisibility(true);

	
	//==========================================================================
	G4Material* wrapMat = nistMan->FindOrBuildMaterial("G4_POLYETHYLENE");
	//G4Material* airgapMat = worldMaterial; //The air gap mat should be air, change this if you change worldmat to be vacuum/galactic		
	G4Material* AlMat = nistMan->FindOrBuildMaterial("G4_Al");
	G4Material* PbMat = nistMan->FindOrBuildMaterial("G4_Pb");

	G4Material* steelMat = nistMan->FindOrBuildMaterial("G4_STAINLESS-STEEL");
	//going to use concrete as a first order approximation to rock, since it's close and we just want something dense
	G4Material* concreteMat = nistMan->FindOrBuildMaterial("G4_CONCRETE");
	
	G4Material* silicaMat = new G4Material("SiO2", 2.65 * g / cm3, 2);
	silicaMat->AddElement(elSi, 1);
	silicaMat->AddElement(elO, 2);


//Container volume so we can rotate the entire detector at once

	G4RotationMatrix* detRot = new G4RotationMatrix();
	G4RotationMatrix* detRotsub = new G4RotationMatrix();
//	detRotsub->rotateX(-90*deg);
	//detRot->rotateX(90*deg);
	detRot->rotateZ(180*deg);
	detRot->rotateY(worldRotation-90*degree); //worldRotation-45*degree
///*
	G4Box* detectorWorldSolid = new G4Box("detectorWorldSolid",
				overallDetX+20*cm,
				overallDetY-5*cm,
				detLength/2+20*cm);
//*/
	G4LogicalVolume* detectorWorldLogic = new G4LogicalVolume(
				detectorWorldSolid,
				worldMaterial,
				"detectorWorldLogic",
				0,0,0);
/*
	G4PVPlacement* detectorWorldPhysic = new G4PVPlacement(
				detRot,
				G4ThreeVector(centerOffsetX, 0, centerOffsetZ),
				detectorWorldLogic,
				"detectorWorldPhysic",
				logicWorld,
				false,
				0,
				true);
*/
////////////////////////////////////////////////////////////////////////////////////
//Overall volume for 2x2 stack

	G4Box* subStackSolid = new G4Box("subStackSolid",
				(2*scintXY+barSpacingInter+0.5*mm),
				(2*scintXY+barSpacingInter+0.5*mm),
				detLength/2-7.5*cm);

	G4LogicalVolume* subStackLogic = new G4LogicalVolume(
				subStackSolid,
				worldMaterial,
				"subStackLogic",
				0,0,0);
///*
	G4PVPlacement* subStackPhysic = new G4PVPlacement(
				0,
				G4ThreeVector(),
				subStackLogic,
				"subStackPhysic",
				logicWorld,
				false,
				0,
				true);
//*/

////////////////////////////////////////////////////////////////////////////////////////////////////
//Rock to be penetrated by muons as a test. Turn this off by commenting out the placement line below
////////////////////////////////////////////////////////////////////////////////////////////////////
//	G4RotationMatrix* wallRot = new G4RotationMatrix();
//	wallRot->rotateY(43.1*deg);

floorCutoutDepthX = 3.8*m/2;
floorCutoutDepthY = (4*m+overallDetY*2+10*cm)/2;
floorZ = 3.7*m/2;


	G4Box* wallsAndCeil = new G4Box("wallsAndCeil",
				floorCutoutDepthX+1.5*m,
				floorCutoutDepthY+1*m,
				floorZ);

	G4Box* floorCutout = new G4Box("floorCutout",
				floorCutoutDepthX,
				floorCutoutDepthY,
				floorZ*1.1);

	G4RotationMatrix* rot = new G4RotationMatrix();
	G4SubtractionSolid* rockSolidWalls = new G4SubtractionSolid("rockSolidWalls",
				wallsAndCeil,
				floorCutout,
				rot,
				G4ThreeVector(0,0,0));
				//G4ThreeVector(0,0,0));

	G4Box* ext = new G4Box("ceilExt",
				1.5*m/2,
				floorCutoutDepthY+1*m,
				10*m);

	G4UnionSolid* rockSolidfloor = new G4UnionSolid("rockSolidfloor",
				rockSolidWalls,
				ext,
				rot,
				G4ThreeVector(-floorCutoutDepthX-1.5*m/2,0,0));
	
	G4UnionSolid* rockSolid = new G4UnionSolid("rockSolidfloor",
				rockSolidfloor,
				ext,
				rot,
				G4ThreeVector(floorCutoutDepthX+1.5*m/2,0,0));

	G4LogicalVolume* rockLogic = new G4LogicalVolume(
				rockSolid,
				//
				//silicaMat,
				concreteMat,
				//PbMat, //testing muon-induced neutrons
				"rockLogic",
				0,0,0);
////////////////////////////////////////////// TURN CAVERN ON/OFF BY COMMENTING OR UNCOMMENTING THIS CODE BLOCK /////////////////////
/*
	G4PVPlacement* rockPhysic = new G4PVPlacement(
				rot,
				//wallRot,
				//G4ThreeVector(50*cm,0,0),//muonLoc: 20*cm+ScintSlabOffsetZEnd+ScintSlabZ+scintZ), //20cm from end of slab, plus add space for slabZ and bar thickness
				G4ThreeVector(floorCutoutDepthX-overallDetX-5*cm,floorCutoutDepthY-overallDetY,0),//10 cm looks about right, so I'm using that as the cavern offset (so the floor is close to the bottom of the detector)
				rockLogic,
				"rockPhysic",
				logicWorld,
				false,
				0,
				true);
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///*	
	G4VisAttributes* rockVis = new G4VisAttributes(
			G4Colour::White());
	rockVis->SetColour(0.64,0.16,0.16,0.2);
	rockVis->SetVisibility(true);
	rockLogic->SetVisAttributes(rockVis);
//*/
/////////////////////////////////////////////////////////////////////////////////
//                            Wrapping Geometry                                //
/////////////////////////////////////////////////////////////////////////////////	

	G4Tubs* wrap_PMT_hole = new G4Tubs("wrap_PMT_hole",
			0,
			outerRadius_cath,
			//outerRadius_pmt,
			(wrapThickness+airGapThickness)/2,
			0*deg,
			360*deg);	

	
///* //geometry to be used when photocathode is attached to PMT
	G4Box* wrap_solid_total = new G4Box("wrap_solid_total",
			wrapXY,
			wrapXY,
			wrapZ);

//	G4ThreeVector* subVec = new G4ThreeVector(0,0,wrapX-wrapThickness/2);
	G4SubtractionSolid* wrap_solid = new G4SubtractionSolid("wrap_solid",
			wrap_solid_total,
			wrap_PMT_hole,
			rot,
			//11 mm is y-axis PMT offset
			G4ThreeVector(0,0,wrapZ-(airGapThickness+wrapThickness)/2));
//*/
/*
//geometry to be used when photocathode is attached to end of Bar
	G4Box* wrap_solid = new G4Box("wrap_solid",
			wrapXY,
			wrapXY,
			wrapZ);
*/

	G4LogicalVolume* wrap_logic = new G4LogicalVolume(
			wrap_solid,
			wrapMat,
			"wrap_logic",
			0, 0, 0);

	
	G4double barShift = scintXY+barSpacingInter;

        G4Tubs* Cwrap_PMT_hole = new G4Tubs("Cwrap_PMT_hole",
                        0,
                        outerRadius_cath,
                        //outerRadius_pmt,
                        (CwrapThickness+CairGapThickness)/2,
                        0*deg,
                        360*deg);


///* //geometry to be used when photocathode is attached to PMT
        G4Box* Cwrap_solid_total = new G4Box("Cwrap_solid_total",
                        CwrapXY,
                        CwrapXY,
                        CwrapZ);

        G4SubtractionSolid* Cwrap_solid = new G4SubtractionSolid("Cwrap_solid",
                        Cwrap_solid_total,
                        Cwrap_PMT_hole,
                        rot,
                        //11 mm is y-axis PMT offset
                        G4ThreeVector(0,0,CwrapZ-(CairGapThickness+CwrapThickness)/2));

        G4LogicalVolume* Cwrap_logic = new G4LogicalVolume(
                        Cwrap_solid,
                        wrapMat,
                        "Cwrap_logic",
                        0, 0, 0);

////////////////// Bench Testing Placement ///////////////



/*	
	G4PVPlacement* wrap_physic = new G4PVPlacement(
			0,
			G4ThreeVector(20*cm,0,0),
			wrap_logic,
			"wrap_physic",
			logicWorld,
			false,
			0,
			true);
*/
	
/////////////////////////////////////////////////////////////////////////////////
//                            Air Gap Geometry                                //
/////////////////////////////////////////////////////////////////////////////////	

	G4Box* airgap_solid_total = new G4Box("airgap_solid_total",
			airgapX,
			airgapY,
			airgapZ);

	G4Tubs* airgap_PMT_hole = new G4Tubs("airgap_PMT_hole",
			0,
			outerRadius_pmt,
			airGapThickness/2,
			0*deg,
			360*deg);	

	G4RotationMatrix* rot2 = new G4RotationMatrix();
//	G4ThreeVector* subVec = new G4ThreeVector(0,0,wrapX-wrapThickness/2);
	G4SubtractionSolid* airgap_solid = new G4SubtractionSolid("airgap_solid",
			airgap_solid_total,
			airgap_PMT_hole,
			rot2,
			//11 mm is y-axis PMT offset
			G4ThreeVector(0,pmtYoffset,airgapZ-airGapThickness/2));

	G4LogicalVolume* airgap_logic = new G4LogicalVolume(
			airgap_solid,
			worldMaterial,
			"airgap_logic",
			0, 0, 0);

	G4PVPlacement* airgap_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			airgap_logic,
			"airgap_physic",
			wrap_logic,
			false,
			0,
			true);

        G4Box* Cairgap_solid_total = new G4Box("Cairgap_solid_total",
                        CairgapX,
                        CairgapY,
                        CairgapZ);

        G4Tubs* Cairgap_PMT_hole = new G4Tubs("Cairgap_PMT_hole",
                        0,
                        outerRadius_pmt,
                        CairGapThickness/2,
                        0*deg,
                        360*deg);       
	

        G4SubtractionSolid* Cairgap_solid = new G4SubtractionSolid("Cairgap_solid",
                        Cairgap_solid_total,
                        Cairgap_PMT_hole,
                        rot2,
                        //11 mm is y-axis PMT offset
                        G4ThreeVector(0,pmtYoffset,CairgapZ-CairGapThickness/2));

        G4LogicalVolume* Cairgap_logic = new G4LogicalVolume(
                        Cairgap_solid,
                        worldMaterial,
                        "Cairgap_logic",
                        0, 0, 0);
          
        G4PVPlacement* Cairgap_physic = new G4PVPlacement(
                        0,
                        G4ThreeVector(),
                        Cairgap_logic,
                        "Cairgap_physic",
                        Cwrap_logic,
                        false,
                        0,
                        true);
        

/////////////////////////////////////////////////////////////////////////////////
//                            Scintillator Geometry                                //
/////////////////////////////////////////////////////////////////////////////////	
        G4Box* CplScin_solid = new G4Box("CplScin_solid",
                                CscintX, 
                                CscintY,
                                CscintZ);
        
        G4LogicalVolume* CplScin_logic = new G4LogicalVolume(
                                CplScin_solid,
                                matCeBr3,
                                //matPlScin,
                                "CplScin_logic",
                                0, 0, 0);

        G4PVPlacement* CplScin_physic = new G4PVPlacement(
                        0,
                        G4ThreeVector(),
                        CplScin_logic,
                        "CplScin_physic",
                        Cairgap_logic,
                        false,
                        0,
                        true);
        





	G4Box* plScin_solid = new G4Box("plScin_solid",
				scintX, 
				scintY,
				scintZ);

	G4LogicalVolume* plScin_logic = new G4LogicalVolume(
				plScin_solid,
				matPlScin,
				"plScin_logic",
				0, 0, 0);

	G4PVPlacement* plScin_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			plScin_logic,
			"plScin_physic",
			airgap_logic,
			false,
			0,
			true);
//G4Region* region1= new G4Region("region1");
//wrap_logic->SetRegion(region1);
//region1->AddRootLogicalVolume(wrap_logic);
//GB01BOptrMultiParticleChangeCrossSection* testMany = new GB01BOptrMultiParticleChangeCrossSection();
//testMany->AddParticle("nu_mu");
//testMany->AttachTo(plScin_logic);


	
//attaching photocathode to end of bar so it detects right
/*
	 G4Tubs* phCathSolidBar = new G4Tubs(
			 "photocath_tube_Bar",
			 0,
			 outerRadius_pmt,
	//		 (airGapThickness+wrapThickness)/2,
			 height_cath/2,
			 0*deg,
			 360*deg);

	 G4LogicalVolume* phCathLogBar = new G4LogicalVolume(phCathSolidBar,
					matBiAlkali,
					"phCathLogBar");
*/
//	 G4ThreeVector phCathPosition(0,0,(-height_pmt/2 + height_cath/2));
//	 G4ThreeVector phCathPosition(0,0,scintZ+(airGapThickness+wrapThickness)/2);
//	 G4ThreeVector phCathPositionBar(0,0,scintZ-height_cath/2);
/*
	 G4PVPlacement* phCathPhysBar = new G4PVPlacement(
			 0,
			 phCathPositionBar,
			 phCathLogBar,
			 "phCathPhysBar",
			 plScin_logic,
			 //wrap_logic,
			 //pmtLog,
			 false,
			 0,
			 true);
*/

////////////////////////////////////Parameterization placement//////////////////////////

///*

	G4double sourceDist[nLayers];

	sourceDist[0]=interactionDist;
	sourceDist[1]=sourceDist[0]+(midLayerMid-frontLayerMid);
	sourceDist[2]=sourceDist[1]+(backLayerMid-midLayerMid);
	sourceDist[3]=sourceDist[2]+(fourthLayerMid-backLayerMid);

	G4double barStack_offset = (scintZ-wrapZ)/2;
	G4double layerPos = 0;
	G4double ScintSlabPlaceZ = 0;
	G4RotationMatrix rotPanL = G4RotationMatrix();
	G4RotationMatrix rotPanR = G4RotationMatrix();
	rotPanR.rotateX(180*degree);
	rotPanR.rotateZ(80*degree);
	rotPanL.rotateY(180*degree);
	rotPanL.rotateZ(-80*degree);
	G4ThreeVector panelPlace(0,0,0);
///*
	G4Box* barStack_solid = new G4Box("barStack_solid",
			        nBarsX*barSpacingXY/2,
				nBarsY*barSpacingXY/2,
				detLength/2);
//*/	
	G4LogicalVolume* barStack_logic = new G4LogicalVolume(
				barStack_solid,
				worldMaterial,
				"barStack_logic",
				0,0,0);
	
        G4ThreeVector barStackPlacement(0,0,0);
	G4RotationMatrix* barStack_rot = new G4RotationMatrix();


        G4double PMTStack_offset = scintZ+height_pmt/2;

	G4double PMTSourceDist[nLayers];
	for(int k=0;k<nLayers;k++) PMTSourceDist[k]=sourceDist[k]+PMTStack_offset;

	G4Box* PMTStack_solid[nLayers];
	G4VPVParameterisation* PMTParam[nLayers];
	
	G4LogicalVolume* PMTStack_logic[nLayers];
	G4PVPlacement* PMTStack_physic[nLayers];
	G4PVParameterised* PMTParamPhys[nLayers];

	G4double PanelToPMT = ScintPanelY+height_pmt/2;
	G4double LPanelToPMTX= -PanelToPMT*cos(10*degree);
	G4double RPanelToPMTX= -PanelToPMT*cos(10*degree);
	G4double LPanelToPMTY= -PanelToPMT*sin(10*degree);
	G4double RPanelToPMTY= PanelToPMT*sin(10*degree);

	G4ThreeVector muMetalPlacement(centerOffsetX, 0, muMetalThickness/2); //adjusting Z in loop
        G4ThreeVector PMTStackPlacement(centerOffsetX, 0, 0); //adjusting Z in loop
	G4ThreeVector PMTSlabPlacement(ScintSlabX-outerRadius_pmt+ScintSlabOffsetX, ScintSlabY+height_pmt/2, 0); //adjusting Z in loop

	G4ThreeVector PMTPanelPlacementTop1(ScintPanelOffsetXTop, -ScintPanelY-height_pmt/2, 0); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementBottom1(ScintPanelOffsetXBottom, -ScintPanelY-height_pmt/2, 0); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementRight1(ScintPanelOffsetXRight+RPanelToPMTX, ScintPanelOffsetYRight+RPanelToPMTY, -ScintPanelZ+outerRadius_pmt); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementLeft1(ScintPanelOffsetXLeft+LPanelToPMTX, ScintPanelOffsetYLeft+LPanelToPMTY, -ScintPanelZ+outerRadius_pmt); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementTop2(ScintPanelOffsetXTop, ScintPanelY+height_pmt/2, 0); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementBottom2(ScintPanelOffsetXBottom, ScintPanelY+height_pmt/2, 0); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementRight2(ScintPanelOffsetXRight-RPanelToPMTX, ScintPanelOffsetYRight-RPanelToPMTY, -ScintPanelZ+outerRadius_pmt); //adjusting Z in loop
	G4ThreeVector PMTPanelPlacementLeft2(ScintPanelOffsetXLeft-LPanelToPMTX, ScintPanelOffsetYLeft-LPanelToPMTY, -ScintPanelZ+outerRadius_pmt); //adjusting Z in loop
	
	G4RotationMatrix* pmt1RotSlab = new G4RotationMatrix();
	G4RotationMatrix* pmt2RotSlab = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelTop1 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelBottom1 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelLeft1 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelRight1 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelTop2 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelBottom2 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelLeft2 = new G4RotationMatrix();
	G4RotationMatrix* pmtRotPanelRight2 = new G4RotationMatrix();

	G4RotationMatrix* rotDetPart = new G4RotationMatrix();

	pmt1RotSlab->rotateX(-90*degree);
	pmt2RotSlab->rotateX(90*degree);
	pmtRotPanelTop1->rotateX(-90*degree);
	pmtRotPanelTop2->rotateX(90*degree);
	pmtRotPanelBottom1->rotateX(-90*degree);
	pmtRotPanelBottom2->rotateX(90*degree);
	
	pmtRotPanelRight1->rotateX(90*degree);
	pmtRotPanelRight1->rotateY(80*degree);
	pmtRotPanelRight2->rotateX(-90*degree);
	pmtRotPanelRight2->rotateY(100*degree);
	
	pmtRotPanelLeft1->rotateX(-90*degree);
	pmtRotPanelLeft1->rotateY(80*degree);
	pmtRotPanelLeft2->rotateX(90*degree);
	pmtRotPanelLeft2->rotateY(100*degree);

	G4double pmtTotalOffsetZ = 0;

	G4RotationMatrix* PMTStack_rot = new G4RotationMatrix();

G4Box* LeadShieldSolid = new G4Box("LeadShieldSolid",
				LeadX,
				LeadY,
				LeadZ);
		
G4LogicalVolume* LeadShieldLogic = new G4LogicalVolume(
					LeadShieldSolid,
					PbMat,
					"LeadShieldLogic",
					0,0,0);
/*
        G4PVPlacement* LeadShieldPhysic = new G4PVPlacement(
                        0,
                        G4ThreeVector(),
                        airgap_logic,
                        "airgap_physic",
                        wrap_logic,
                        false,
                        0,
                        true);
*/


/////////////////////////////////////////////////////////////////
G4RotationMatrix* rotSlab1 = new G4RotationMatrix();
G4RotationMatrix* rotSlab2 = new G4RotationMatrix();
	rotSlab1->rotateY(90*degree);
	rotSlab2->rotateY(90*degree);

G4Box* ScintSlabWrapSolidTotal = new G4Box("ScintSlabWrapSolidTotal",
				ScintSlabWrapX,
				ScintSlabWrapY,
				ScintSlabWrapZ);
	
G4SubtractionSolid* ScintSlabWrapSolid1 = new G4SubtractionSolid("ScintSlabWrapSolid1",
					ScintSlabWrapSolidTotal,
					wrap_PMT_hole,
					rotSlab1,
					G4ThreeVector(0,
						      -ScintSlabWrapY+(airGapThickness+wrapThickness)/2,
						      ScintSlabZ-outerRadius_pmt));

G4SubtractionSolid* ScintSlabWrapSolid = new G4SubtractionSolid("ScintSlabWrapSolid",
					ScintSlabWrapSolid1,
					wrap_PMT_hole,
					rotSlab2,
					G4ThreeVector(0,
						      -1*(-ScintSlabWrapY+(airGapThickness+wrapThickness)/2),
						      -1*(ScintSlabZ-outerRadius_pmt)));	
 
G4LogicalVolume* ScintSlabWrapLogic = new G4LogicalVolume(
					ScintSlabWrapSolid,
					wrapMat,
					"ScintSlabWrapLogic",
					0,0,0);

G4Box* ScintSlabAirGapSolidTotal = new G4Box("ScintSlabAirGapSolidTotal",
				ScintSlabAirGapX,
				ScintSlabAirGapY,
				ScintSlabAirGapZ);

G4SubtractionSolid* ScintSlabAirGapSolid1 = new G4SubtractionSolid("ScintSlabAirGapSolid1",
					ScintSlabAirGapSolidTotal,
					airgap_PMT_hole,
					rotSlab1,
					G4ThreeVector(0,
						      -ScintSlabAirGapY+airGapThickness/2,
						      ScintSlabZ-outerRadius_pmt));

G4SubtractionSolid* ScintSlabAirGapSolid = new G4SubtractionSolid("ScintSlabAirGapSolid",
					ScintSlabAirGapSolid1,
					airgap_PMT_hole,
					rotSlab2,
					G4ThreeVector(0,
						      -1*(-ScintSlabAirGapY+airGapThickness/2),
						      -1*(ScintSlabZ-outerRadius_pmt)));

G4LogicalVolume* ScintSlabAirGapLogic = new G4LogicalVolume(
					ScintSlabAirGapSolid,
					worldMaterial,
					"ScintSlabAirGapLogic",
					0,0,0);
	
	G4PVPlacement* airGapSlab_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			ScintSlabAirGapLogic,
			"airGapSlab_physic",
			ScintSlabWrapLogic,
			false,
			0,
			true);


///*	
G4Box* ScintSlabSolid = new G4Box("ScintSlabSolid",
				ScintSlabX,
				ScintSlabY,
				ScintSlabZ);

G4LogicalVolume* ScintSlabLogic = new G4LogicalVolume(
					ScintSlabSolid,
					matPlScin,
					"ScintSlabLogic",
					0,0,0);
	G4PVPlacement* slab_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			ScintSlabLogic,
			"slab_physic",
			ScintSlabAirGapLogic,
			false,
			0,
			true);
//*/
//////////////////////////////////////////////////////////////////////////////
G4Box* ScintPanelWrapSolidTotal = new G4Box("ScintPanelWrapSolidTotal",
				ScintPanelWrapX,
				ScintPanelWrapY,
				ScintPanelWrapZ);

G4SubtractionSolid* ScintPanelWrapSolid1 = new G4SubtractionSolid("ScintPanelWrapSolid1",
					ScintPanelWrapSolidTotal,
					wrap_PMT_hole,
					rotSlab1,
					G4ThreeVector(0,
						      -ScintPanelWrapY+(airGapThickness+wrapThickness)/2,
						      ScintPanelZ-outerRadius_pmt));	
G4SubtractionSolid* ScintPanelWrapSolid = new G4SubtractionSolid("ScintPanelWrapSolid",
					ScintPanelWrapSolid1,
					wrap_PMT_hole,
					rotSlab2,
					G4ThreeVector(0,
						      -1*(-ScintPanelWrapY+(airGapThickness+wrapThickness)/2),
						      -1*(ScintPanelZ-outerRadius_pmt)));	

G4LogicalVolume* ScintPanelWrapLogic = new G4LogicalVolume(
					ScintPanelWrapSolid,
					wrapMat,
					"ScintPanelWrapLogic",
					0,0,0);


G4Box* ScintPanelAirGapSolidTotal = new G4Box("ScintPanelAirGapSolidTotal",
				ScintPanelAirGapX,
				ScintPanelAirGapY,
				ScintPanelAirGapZ);
G4SubtractionSolid* ScintPanelAirGapSolid1 = new G4SubtractionSolid("ScintPanelAirGapSolid1",
					ScintPanelAirGapSolidTotal,
					airgap_PMT_hole,
					rotSlab1,
					G4ThreeVector(0,
						      -ScintPanelAirGapY+airGapThickness/2,
						      ScintPanelZ-outerRadius_pmt));

G4SubtractionSolid* ScintPanelAirGapSolid = new G4SubtractionSolid("ScintPanelAirGapSolid",
					ScintPanelAirGapSolid1,
					airgap_PMT_hole,
					rotSlab2,
					G4ThreeVector(0,
						      -1*(-ScintPanelAirGapY+airGapThickness/2),
						      -1*(ScintPanelZ-outerRadius_pmt)));

G4LogicalVolume* ScintPanelAirGapLogic = new G4LogicalVolume(
					ScintPanelAirGapSolid,
					worldMaterial,
					"ScintPanelAirGapLogic",
					0,0,0);
	
	G4PVPlacement* airGapPanel_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			ScintPanelAirGapLogic,
			"airGapPanel_physic",
			ScintPanelWrapLogic,
			false,
			0,
			true);


G4Box* ScintPanelSolid = new G4Box("ScintPanelSolid",
				ScintPanelX,
				ScintPanelY,
				ScintPanelZ);

G4LogicalVolume* ScintPanelLogic = new G4LogicalVolume(
					ScintPanelSolid,
					matPlScin,
					"ScintPanelLogic",
					0,0,0);

	G4PVPlacement* panel_physic = new G4PVPlacement(
			0,
			G4ThreeVector(),
			ScintPanelLogic,
			"panel_physic",
			ScintPanelAirGapLogic,
			false,
			0,
			true);

///////////////////////////////////////////////////////////////////////

//==========================================================================
    //---------------PMT Geometry---------------
    //==========================================================================
//////////////////// defining phCathSolid as PMT so we can parameterise it /////////////
///*
	 G4Tubs* phCathSolid = new G4Tubs(
			 "photocath_tube",
			 0,
			 outerRadius_cath,
	//		 (airGapThickness+wrapThickness)/2,
			 height_pmt/2,
			 0*deg,
			 360*deg);

	 G4LogicalVolume* phCathLog = new G4LogicalVolume(phCathSolid,
					matBiAlkali,
					"phCathLog");

//	 G4ThreeVector phCathPosition(0,0,(-height_pmt/2 + height_cath/2));
//	 G4ThreeVector phCathPosition(0,0,scintZ+height_pmt/2);
	 G4ThreeVector phCathPosition1(20*cm,0,CscintZ+height_pmt/2);
	 G4ThreeVector phCathPosition(20*cm,0,CscintZ+height_pmt/2);
//////////////////// Bench testing ///////////////////////////
///*
	 
	 ///////// add pmt as daughter of photocathode (impacts visualization only)

	 G4Tubs* pmtSolid = new G4Tubs(
			 "pmt_tube",
			 outerRadius_cath,
			 outerRadius_pmt,
		         //(height_pmt-height_cath)/2,
		         height_pmt/2,
		         0*deg,
		         360*deg);

	 G4LogicalVolume* pmtLog = new G4LogicalVolume(
			 pmtSolid,
	 	 	 //matBorGlass, //actually made of matBorGlass, but the material isn't a significant source
			 worldMaterial, //so, going with air (world material) insteadhttps://www.chem.uci.edu/~unicorn/243/handouts/pmt.pdf
 	 		"pmtLog");
/*
	G4PVPlacement* pmtPhys = new G4PVPlacement(
			 0,
			 //G4ThreeVector(0,0,(height_cath+50*mm)/2),
			 //G4ThreeVector(0,0,(height_cath+0.1*mm)/2),
			 phCathPosition,
			 pmtLog,
			 "pmtPhys",
			 logicWorld,
			 false,
			 0,
			 true);
*/

////////////////////////////////////////////////////////////////////////////////////////////////////////
G4double topZ,leftZ,rightZ,botZ,sign, shift;
G4RotationMatrix* rotPanel = new G4RotationMatrix();
rotPanel->rotateY(-1*worldRotation);

for(int l=1;l<nLayers+1;l++){

	 new G4PVPlacement(
			 0,
			 G4ThreeVector(barShift*3,0,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+CscintZ-scintZ),
			 Cwrap_logic,
			 "Cwrap_logic"+std::to_string(l),
			 logicWorld,
			 false,
			 5+l,
			 true);
        
        new G4PVPlacement(
                0,
                G4ThreeVector(barShift*3,0,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+CscintZ+height_pmt/2+CscintZ-scintZ),
                phCathLog,
                "CphCath_physic1_L"+std::to_string(l),
                logicWorld, 
                false,
                5+l,
                true);
}
for(int l=1;l<nLayers+1;l++){

	new G4PVPlacement(
		0,
		G4ThreeVector(barShift,barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt),
		wrap_logic,
		"wrap_physic1_L"+std::to_string(l),
		subStackLogic,
		false,
		1,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(barShift,barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+scintZ+height_pmt/2),
		phCathLog,
		"phCath_physic1_L"+std::to_string(l),
		subStackLogic,
		false,
		1,
		true);


	new G4PVPlacement(
		0,
		G4ThreeVector(barShift,-barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt),
		wrap_logic,
		"wrap_physic2_L"+std::to_string(l),
		subStackLogic,
		false,
		2,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(barShift,-barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+scintZ+height_pmt/2),
		phCathLog,
		"phCath_physic2_L"+std::to_string(l),
		subStackLogic,
		false,
		2,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(-barShift,barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt),
		wrap_logic,
		"wrap_physic3_L"+std::to_string(l),
		subStackLogic,
		false,
		3,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(-barShift,barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+scintZ+height_pmt/2),
		phCathLog,
		"phCath_physic3_L"+std::to_string(l),
		subStackLogic,
		false,
		3,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(-barShift,-barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt),
		wrap_logic,
		"wrap_physic4_L"+std::to_string(l),
		subStackLogic,
		false,
		4,
		true);

	new G4PVPlacement(
		0,
		G4ThreeVector(-barShift,-barShift,-(3-2*l)*(LeadZ+wrapZ)-(2-l)*height_pmt+scintZ+height_pmt/2),
		phCathLog,
		"phCath_physic4_L"+std::to_string(l),
		subStackLogic,
		false,
		4,
		true);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	The PMTs that are actually placed below are strictly the ones coupled to slabs and panels
//
//	The bar-coupled photocathodes actually can't be placed in a separate parameterization volume
//	(except either with expensive multi-union solids or perhaps adjusting the individual end of
//	every bar; it's possible but a headache). So to solve this problem cheaply, I'm just going to
//	move the photocathode volume to be a daughter of the scintillator bars. The rest of the readout
//	PMTs should otherwise be unaffected though.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////    G4 Vis attributes        /////////////////////////////
	
	G4VisAttributes* visAttribplScinExt = new G4VisAttributes(G4Colour::Cyan());
	visAttribplScinExt->SetVisibility(false);
	
	G4VisAttributes* visAttribWrap = new G4VisAttributes(
			G4Colour::White());
	visAttribWrap->SetForceWireframe(false);
	visAttribWrap->SetForceSolid(true);
	visAttribWrap->SetVisibility(true);
	
	G4VisAttributes* visAttribCWrap = new G4VisAttributes(
			G4Colour::Yellow());
	visAttribCWrap->SetForceWireframe(false);
	visAttribCWrap->SetForceSolid(true);
	visAttribCWrap->SetVisibility(true);
	
	G4VisAttributes* visAttribWrapEdge = new G4VisAttributes(
			G4Colour::Black());
	visAttribWrapEdge->SetVisibility(true);
	visAttribWrapEdge->SetForceWireframe(true);
	
	G4VisAttributes* visAttribCWrapEdge = new G4VisAttributes(
			G4Colour::Black());
	visAttribCWrapEdge->SetVisibility(true);
	visAttribCWrapEdge->SetForceWireframe(true);

	G4VisAttributes* visAttribWrapExt = new G4VisAttributes(
			G4Colour::White());
	visAttribWrapExt->SetColour(0.5,0.5,0.5,0.3);
	visAttribWrapExt->SetVisibility(true);

	G4VisAttributes* visAttribLead = new G4VisAttributes(
			G4Colour::Black());
	visAttribLead->SetVisibility(true);
	
	G4VisAttributes* visAttribMuMetal = new G4VisAttributes(
			G4Colour::Black());
	visAttribMuMetal->SetColour(0,0,0,0.1);
	visAttribMuMetal->SetVisibility(true);
	

	wrap_logic->SetVisAttributes(visAttribWrap);
	Cwrap_logic->SetVisAttributes(visAttribCWrap);
	wrap_logic->SetVisAttributes(visAttribWrapEdge);
	Cwrap_logic->SetVisAttributes(visAttribCWrapEdge);
	ScintPanelWrapLogic->SetVisAttributes(visAttribWrapExt);
	ScintSlabWrapLogic->SetVisAttributes(visAttribWrapExt);
	//ScintPanelAirGapLogic->SetVisAttributes(visAttribplScinExt);
	ScintSlabAirGapLogic->SetVisAttributes(visAttWorld);
	ScintPanelAirGapLogic->SetVisAttributes(visAttWorld);
	ScintSlabAirGapLogic->SetVisAttributes(visAttWorld);
	plScin_logic->SetVisAttributes(visAttribplScin);
	ScintSlabLogic->SetVisAttributes(visAttribplScinExt);
	ScintPanelLogic->SetVisAttributes(visAttribplScinExt);
	//HodoWrapLogic->SetVisAttributes(visAttribWrapExt);
	//HodoScintLogic->SetVisAttributes(visAttribplScinExt);

		
	LeadShieldLogic->SetVisAttributes(visAttribWrapExt);//Lead);
//	muMetalShield_logic->SetVisAttributes(visAttribMuMetal);
	detectorWorldLogic->SetVisAttributes(visAttWorld);
//	detectorWorldLogic->SetVisAttributes(visAttribWrapExt);
//	subStackLogic->SetVisAttributes(visAttribplScin);	
	subStackLogic->SetVisAttributes(visAttWorld);	
//	barStack_logic->SetVisAttributes(visAttribplScin);	
	barStack_logic->SetVisAttributes(visAttWorld);	
////////////////////////////////////////////////////////////////////////////
// Long Al Support Placement
if(SupportStructure){
        G4Box* AlSupportSolidFull = new G4Box("AlSupportSolidFull",
                                                AlSupportX,
                                                AlSupportY,
                                                AlSupportZ);

        G4Box* AlSupportSolidHollow = new G4Box("AlSupportSolidHollow",
                                                AlSupportX-AlThickness,
                                                AlSupportY-AlThickness,
                                                AlSupportZ-AlThickness);

	G4SubtractionSolid* AlSupportSolid = new G4SubtractionSolid("AlSupportSolid",
						AlSupportSolidFull,
						AlSupportSolidHollow,
						rot, //unrotated
						G4ThreeVector(0,0,0));

        G4LogicalVolume* AlSupportLogic = new G4LogicalVolume(
                                                AlSupportSolid,
                                                AlMat,
                                                //steelMat,
                                                "AlSupportLogic",
                                                0,0,0);

        G4PVPlacement* AlSupportPhys = new G4PVPlacement(
                                        0,
                                        G4ThreeVector(AlSupportXOffset,0,0),
                                        AlSupportLogic,
                                        "AlSupportPhys",
                                        //logicWorld,
					detectorWorldLogic,
                                        false,
                                        0,
                                        true);
	G4VisAttributes* visAttribAl = new G4VisAttributes(
			G4Colour::Gray());
	visAttribAl->SetVisibility(true);	
	AlSupportLogic->SetVisAttributes(visAttribAl);

}


/*//////////////////////////////////////////////////////////////////////////////////////////////////////
*/
	 //the "photocathode" is a metal slab at the front of the glass that
	 //is only an approximation of the real thing since it only
	 //absorbs or detects the photons based on the efficiency set

//////////////////// moving placement of phCathSolid from PMT to the      ////////////////////////
//////////////////// Bar volume s.t. there are no logical volume overlaps ///////////////////////

   //sensitive detector is not actually on the photocathode.
   //processHits gets done manually by the stepping action.
   //It is used to detect when photons hit and get absorbed&detected at the
   //boundary to the photocathode (which doesnt get done by attaching it to a
   //logical volume.
   //It does however need to be attached to something or else it doesnt get

    //==========================================================================
    //---------------Scintillator Sensitive Detector---------------
    //==========================================================================
/*
	G4SDManager* SDman = G4SDManager::GetSDMpointer();
	G4String SDnameC = "MilliQan/ScintiSensitiveDetector";
	mqScintSD* scintSD = new mqScintSD(SDnameC);
	SDman->AddNewDetector ( scintSD );

	plScin_logic->SetSensitiveDetector(scintSD);

	const int nbAllPmts = nBarXCount*nBarYCount;
  */  
   //reset at the begining of events
   //==========================================================================
   //---------------PMT Sensitive Detector---------------
   //==========================================================================
   G4String SDnameOfPMTDetector = "PMT_SD";
   mqPMTSD* myPMTSD = new mqPMTSD(SDnameOfPMTDetector);

   G4SDManager::GetSDMpointer()->AddNewDetector(myPMTSD);
//	myPMTSD->InitPMTs(nbAllPmts);
	myPMTSD->SetR878_QE(GetPMTEff_R878());
	myPMTSD->SetR7725_QE(GetPMTEff_R7725());
	myPMTSD->SetET9814B_QE(GetPMTEff_ET9814B());
	phCathLog->SetSensitiveDetector(myPMTSD); //change HERE for PMT Scenario
//	phCathLogBar->SetSensitiveDetector(myPMTSD); //change HERE for PMT Scenario

   G4String SDnameOfScintDetector = "Scint_SD";
   mqScintSD* myScintSD = new mqScintSD(SDnameOfScintDetector);

   G4SDManager::GetSDMpointer()->AddNewDetector(myScintSD);
	// visual attributes for all PMTs;
	G4VisAttributes* visAttribPMT = new G4VisAttributes(G4Colour::Blue());
	visAttribPMT->SetForceWireframe(false);
	visAttribPMT->SetForceSolid(true);
	visAttribPMT->SetVisibility(true);

	//setting same color so it doesn't look bad in isometric view
	
	G4VisAttributes* visAttribPhCath = new G4VisAttributes(G4Colour::Blue());
	//G4VisAttributes* visAttribPhCath = new G4VisAttributes(G4Colour::Red());
	visAttribPhCath->SetForceWireframe(false);
	visAttribPhCath->SetForceSolid(false);
	visAttribPhCath->SetVisibility(true);

	pmtLog->SetVisAttributes(visAttribPMT);
	phCathLog->SetVisAttributes(visAttribPhCath);
	//phCathLogBar->SetVisAttributes(visAttribPhCath);

	//==============================================================================
	// Optical Surfaces
	//==============================================================================
	// Optical Properties
	// Note that, as mentioned in HyperNews posts and the G4AppDev Guide, the definition
	// of a logical bordfer surface involves a ordered pair of materials, such that
	// despite there being no clearly defined structure/class in the prototpye, the
	// order in which the surfaces are listed defines the orientation of the surface;
	// particles "see" this surface only when traveling from the first listed physical
	// volume into the second, which is why I have created a pair of complementary
	// surfaces for every interface (producing identical, bidirectional interactions).


    G4OpticalSurface* opSDielectricBiAlkali = new G4OpticalSurface("Detector", unified,
                                                    polished, dielectric_metal);
    //////////////////
    G4MaterialPropertiesTable* mtphcath =  matBiAlkali->GetMaterialPropertiesTable();
    opSDielectricBiAlkali->SetMaterialPropertiesTable(mtphcath);
    opSDielectricBiAlkali->SetMaterialPropertiesTable(SetOpticalPropertiesOfPMT());

    G4OpticalSurface* opSWrapScintillator = new G4OpticalSurface("Wrapping", unified,
                              /*ground*/      groundteflonair,
                                                dielectric_metal);
	const G4int nEntriesWrap = 2;
	G4double photonEnergyWrap[nEntriesWrap]={ 1.5 * eV,6.3 * eV};
	G4double wrap_REFL[nEntriesWrap] = {wrapRefl,wrapRefl};//{0.95,0.95}
//	G4double wrap_RIND[nEntriesWrap];

	G4MaterialPropertiesTable* mptWrap = new G4MaterialPropertiesTable();
	//mptWrap->AddProperty("TRANSMITTANCE",photonEnergyWrap, foil_REFL, nEntriesWrap);//->SetSpline(true);
	mptWrap->AddProperty("REFLECTIVITY",photonEnergyWrap, wrap_REFL, nEntriesWrap);
    
    opSWrapScintillator->SetMaterialPropertiesTable(mptWrap);

////////////////// PMT non-photocath refl ///////////////////////////
    G4OpticalSurface* opSPMT = new G4OpticalSurface("PMT Dead Zone", unified,
                              /*ground*/      polished,
                                                dielectric_metal);
        G4double photonEnergyPMT[nEntriesWrap]={ 1.5 * eV,6.3 * eV};
        G4double wrap_PMT[nEntriesWrap] = {0,0};//{0.95,0.95}
//      G4double wrap_RIND[nEntriesWrap];

        G4MaterialPropertiesTable* mptPMT = new G4MaterialPropertiesTable();
        //mptWrap->AddProperty("TRANSMITTANCE",photonEnergyWrap, foil_REFL, nEntriesWrap);//->SetSpline(true);
        mptPMT->AddProperty("REFLECTIVITY",photonEnergyPMT, wrap_PMT, nEntriesWrap);

    opSPMT->SetMaterialPropertiesTable(mptPMT);
/////////////////////////////////////////////////////////////////////// 

//define optical surfaces for each object in the sim, and match the optical properties of each surface to it

    new G4LogicalSkinSurface("Wrap", wrap_logic, opSWrapScintillator);
    new G4LogicalSkinSurface("Wrap", ScintPanelWrapLogic, opSWrapScintillator);
    new G4LogicalSkinSurface("Wrap", ScintSlabWrapLogic, opSWrapScintillator);
    new G4LogicalSkinSurface("PhCath", phCathLog, opSDielectricBiAlkali);
    new G4LogicalSkinSurface("PMTDeadZone", pmtLog, opSPMT);

//Connect detector volume (photocathode) to each surface which is in contact with it
// use this if you want to explicitly define the allowed optical surfaces rather than a wrapping
//        new G4LogicalBorderSurface("Glass->PhCath",
//			pmtPhys,phCathPhys,opSDielectricBiAlkali);
//			PMTParam_phys,phCathPhys,opSDielectricBiAlkali);

//	new G4LogicalBorderSurface("PhCath->Glass",
//			phCathPhys,pmtPhys,opSDielectricBiAlkali);
//			phCathPhys,PMTParam_phys,opSDielectricBiAlkali);
/*
    new G4LogicalBorderSurface("Scinti->PhCathBar",
//			barParamPhys[0], PMTParamPhys[0] ,opSDielectricBiAlkali);
			plScin_physic, phCathPhys ,opSDielectricBiAlkali);

    new G4LogicalBorderSurface("PhCathBar->Scinti",
//    			PMTParamPhys[0] ,barParamPhys[0] ,opSDielectricBiAlkali);
    			phCathPhys ,plScin_physic ,opSDielectricBiAlkali);
*/
/*
    new G4LogicalBorderSurface("AirGap->PhCath",
			airgap_physic, phCathPhysBar ,opSDielectricBiAlkali);

    new G4LogicalBorderSurface("PhCath->AirGap",
    			phCathPhysBar ,airgap_physic ,opSDielectricBiAlkali);
*/
//*/


    return physicWorld;

}

void mqDetectorConstruction::SetMagField(G4double fieldValueX, G4double fieldValueY, G4double fieldValueZ) {

  fMonFieldSetup->SetMagField(fieldValueX, fieldValueY, fieldValueZ);

}

G4MaterialPropertiesTable* mqDetectorConstruction::SetOpticalPropertiesOfPS(){


G4MaterialPropertiesTable* mptPlScin = new G4MaterialPropertiesTable();

 const G4int nEntries= 43;//301;//100;

	G4double EJ200_SCINT[nEntries];
	G4double EJ200_RIND[nEntries];
	G4double EJ200_ABSL[nEntries];
	G4double photonEnergy[nEntries];

	std::ifstream ReadEJ200;
	G4int ScintEntry=0;
	G4String filler;
	G4double pEnergy;
	G4double pWavelength;
	G4double pSEff;
	G4cout << "mqOpticalFilePath is: " << mqOpticalFilePath << G4endl;
	ReadEJ200.open(mqOpticalFilePath+"EJ200ScintSpectrum.txt");
	if(ReadEJ200.is_open()){
	while(!ReadEJ200.eof()){
	ReadEJ200 >> pWavelength >> pSEff;
	pEnergy = (1240/pWavelength)*eV;
	photonEnergy[ScintEntry] = pEnergy;
	EJ200_SCINT[ScintEntry] = pSEff;
	G4cout << "read-in energy scint: " << photonEnergy[ScintEntry] << " eff: " << EJ200_SCINT[ScintEntry] << G4endl;
	ScintEntry++;
	}
	}
	else
	G4cout << "Error opening file: " << "EJ200ScintSpectrum.txt" << G4endl;
	ReadEJ200.close();


	for (int i = 0; i < nEntries; i++) {
		EJ200_RIND[i] = 1.58;//58; // refractive index at 425 nm
		//EJ200_ABSL[i] *= myPSAttenuationLength;
		EJ200_ABSL[i] = 3.8*m;//2.5 * m; // bulk attenuation at 425 nm
	}

	mptPlScin->AddProperty("FASTCOMPONENT", photonEnergy, EJ200_SCINT,
			nEntries);//->SetSpline(true);


	mptPlScin->AddProperty("ABSLENGTH", photonEnergy, EJ200_ABSL,
				nEntries);//->SetSpline(true);

	mptPlScin->AddConstProperty("SCINTILLATIONYIELD", 10000. / MeV); //--- according to EJ200
	mptPlScin->AddConstProperty("RESOLUTIONSCALE", 1.0);
	mptPlScin->AddConstProperty("FASTTIMECONSTANT", 2.1 * ns); //decay time, according to EJ200
	mptPlScin->AddProperty("RINDEX", photonEnergy, EJ200_RIND, nEntries);//->SetSpline(true);

return mptPlScin;
}

G4MaterialPropertiesTable* mqDetectorConstruction::SetOpticalPropertiesOfCeBr3(){


G4MaterialPropertiesTable* mptCeBr3 = new G4MaterialPropertiesTable();

 const G4int nEntries= 36;//301;//100;

        G4double CeBr3_SCINT[nEntries];
        G4double CeBr3_RIND[nEntries];
        G4double CeBr3_ABSL[nEntries];
        G4double photonEnergy[nEntries];

        std::ifstream ReadCeBr3;
        G4int ScintEntry=0;
        G4String filler;
        G4double pEnergy;
        G4double pWavelength;
        G4double pSEff;
        G4cout << "mqOpticalFilePath is: " << mqOpticalFilePath << G4endl;
        ReadCeBr3.open(mqOpticalFilePath+"CeBr3ScintSpectrum.txt");
        if(ReadCeBr3.is_open()){
        while(!ReadCeBr3.eof()){
        ReadCeBr3 >> pWavelength >> pSEff;
        pEnergy = (1240/pWavelength)*eV;
        photonEnergy[ScintEntry] = pEnergy;
        CeBr3_SCINT[ScintEntry] = pSEff;
        G4cout << "read-in energy scint: " << photonEnergy[ScintEntry] << " eff: " << CeBr3_SCINT[ScintEntry] << G4endl;
        ScintEntry++;
        }
        }
        else
        G4cout << "Error opening file: " << "CeBr3ScintSpectrum.txt" << G4endl;
        ReadCeBr3.close();


        for (int i = 0; i < nEntries; i++) {
                CeBr3_RIND[i] = 2.09;//58; // refractive index at 425 nm
                //CeBr3_ABSL[i] *= myPSAttenuationLength;
                CeBr3_ABSL[i] = 0.1*m;//2.5 * m; // bulk attenuation at 425 nm
        }

        mptCeBr3->AddProperty("FASTCOMPONENT", photonEnergy, CeBr3_SCINT,
                        nEntries);//->SetSpline(true);


        mptCeBr3->AddProperty("ABSLENGTH", photonEnergy, CeBr3_ABSL,
                                nEntries);//->SetSpline(true);

        mptCeBr3->AddConstProperty("SCINTILLATIONYIELD", 60000. / MeV); //--- according to CeBr3
        mptCeBr3->AddConstProperty("RESOLUTIONSCALE", 1.0);
        mptCeBr3->AddConstProperty("FASTTIMECONSTANT", 19 * ns); //decay time, according to CeBr3
        mptCeBr3->AddProperty("RINDEX", photonEnergy, CeBr3_RIND, nEntries);//->SetSpline(true);

return mptCeBr3;
}


G4MaterialPropertiesTable* mqDetectorConstruction::SetOpticalPropertiesOfPMT(){

	G4MaterialPropertiesTable* mptPMT = new G4MaterialPropertiesTable();

	const G4int nEntriesPMT = 41;//27;//36;//2;//37;//15; //just figure out how many entries are in the text file,
								//unless you're not lazy like me and want to dynamically allocate memory
//* PMT QEff read-in (updated Jan 2018)
	G4double photonEnergyPMT[nEntriesPMT];
	G4double photocath_EFF[nEntriesPMT];
	G4double PhCath_REFL[nEntriesPMT]; // to be determined
	
	std::ifstream ReadPMTQEff;
	G4int PMTEntry=0;
	G4String filler;
	G4double pEnergy;
	G4double pWavelength;
	G4double pQEff;
	ReadPMTQEff.open(mqOpticalFilePath+"PMT_R878_QE_orig.txt");
	if(ReadPMTQEff.is_open()){
	while(!ReadPMTQEff.eof()){
	ReadPMTQEff >> pWavelength >> pQEff;
	pQEff=1;
	pEnergy = (1240/pWavelength)*eV;
	photonEnergyPMT[PMTEntry] = pEnergy;
	photocath_EFF[PMTEntry] = pQEff;
	PhCath_REFL[PMTEntry] = 0;
	G4cout << "read-in energy: " << photonEnergyPMT[PMTEntry] << " eff: " << photocath_EFF[PMTEntry] << G4endl;
	PMTEntry++;
	}
	}
	else
	G4cout << "Error opening file: " << "PMT_R878_QE.txt" << G4endl;
	ReadPMTQEff.close();
/*	
	G4double PhCath_REFL[nEntriesPMT] = { // to be determined
			0., 0.,0.,0.,0.,0.,0.,0.,0.,0.,
			0., 0.,0.,0.,0.//,0.,0.,0.,0.,0.,
			//0., 0.,0.,0.,0.,0.,0.//,0.,0.,0.,
			//0., 0.,0.,0.,0.,0.//,0.
			};
*/

	mptPMT->AddProperty("REFLECTIVITY", photonEnergyPMT,PhCath_REFL, nEntriesPMT);//->SetSpline(true);
	mptPMT->AddProperty("EFFICIENCY",photonEnergyPMT,photocath_EFF,nEntriesPMT);//->SetSpline(true);

	G4cout << "successfully at end of PMT optical table" << G4endl;
	
	return mptPMT;

}

G4PhysicsVector mqDetectorConstruction::GetPMTEff_R878(){
	
	std::ifstream ReadPMTQEff;
	ReadPMTQEff.open(mqOpticalFilePath+"PMT_R878_QE.txt");
	G4PhysicsVector effVec;
	effVec.Retrieve(ReadPMTQEff,true);
	if (effVec.GetVectorLength()!=0) G4cout << "Quantum Efficiency successfully retrieved for PMT_R878_QE" << G4endl;
	else G4cout << "ERROR: Vector length is zero!" << G4endl;
	effVec.ScaleVector(1,2*0.884); //multiplying by 2 for scaling purposes
	ReadPMTQEff.close();
	return effVec;
}

G4PhysicsVector mqDetectorConstruction::GetPMTEff_R7725(){
	
	std::ifstream ReadPMTQEff;
	ReadPMTQEff.open(mqOpticalFilePath+"PMT_R7725_QE.txt");
	G4PhysicsVector effVec;
	effVec.Retrieve(ReadPMTQEff,true);
	if (effVec.GetVectorLength()!=0) G4cout << "Quantum Efficiency successfully retrieved for PMT R7725" << G4endl;
	else G4cout << "ERROR: Vector length is zero!" << G4endl;
	effVec.ScaleVector(1,2*0.884); //multiplying by 2 for scaling purposes
	ReadPMTQEff.close();
	return effVec;
}

G4PhysicsVector mqDetectorConstruction::GetPMTEff_ET9814B(){
	std::ifstream ReadPMTQEff;
	ReadPMTQEff.open(mqOpticalFilePath+"PMT_ET9814B_QE.txt");
	G4PhysicsVector effVec;
	effVec.Retrieve(ReadPMTQEff,true);
	if (effVec.GetVectorLength()!=0) G4cout << "Quantum Efficiency successfully retrieved for PMT ET9814B" << G4endl;
	else G4cout << "ERROR: Vector length is zero!" << G4endl;
	effVec.ScaleVector(1,2*0.884); //multiplying by 2 for scaling purposes
	ReadPMTQEff.close();
	return effVec;
}

void mqDetectorConstruction::UpdateGeometry() {
	if (verbose >= 0) {
		G4cout << "MilliQan> Update geometry." << G4endl;
		G4cout
				<< "               Don't use this command explicitly, it's obsolete and can crash the run."
				<< G4endl;
	}
	// clean-up previous geometry
    G4GeometryManager::GetInstance()->OpenGeometry();
    G4PhysicalVolumeStore::GetInstance()->Clean();
    G4LogicalVolumeStore::GetInstance()->Clean();
    G4SolidStore::GetInstance()->Clean();
    G4LogicalSkinSurface::CleanSurfaceTable();
    G4LogicalBorderSurface::CleanSurfaceTable();
    G4SurfaceProperty::CleanSurfacePropertyTable();
    //define new one
	G4RunManager::GetRunManager()->DefineWorldVolume(Construct());
	G4RunManager::GetRunManager()->GeometryHasBeenModified();
	updated=false;
}


void mqDetectorConstruction::SetDefaults(){
  //Resets to default values


  updated=true;
}



